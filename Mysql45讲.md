### 一条sql查询语句是如何执行的



![avatar](\images\0d2070e8f84c4801adbfa03bda1f98d9.png)



mysql分为 server层 和存储引擎

server层包括连接器，查询缓存，分析器，优化器，执行器，  内置函数 存储过程 触发器 视图 都在server层

存储引擎负责数据的存储和提取，分为InnoDB 	MyISAM	Memory等多个存储引擎，mysql5.6之后默认使用InnoDB

SELECT * FROM T WHERE ID=? 是如何执行的

1.连接器 长连接 短连接

2.查询缓存，是否之前执行过该语句，如果执行过该语句，在缓存内存中 语句和结果集 以 <K,V>结构存储。往往不建议开启缓存查询，因为命中率很低，频繁的更新清空，造成数据库压力。

3.没有命中缓存查询，进入到分析器，进行词法分析(分词关键词)，识别 select关键字 识别字符串T为 表名T，ID为列ID；然后进行语法分析（分析 整体sql是否符合 mysql语法）。

4.然后进入优化器，生成执行计划，其中包括表的连接顺序 索引的选择等

5.执行器 首先判断对该表是有查询的权限， 打开表， 根据表的引擎定义 扫描表，找出符合条件的数据形成结果集 返回客户端。



### 一条 update 语句是怎么执行的

![03eec4e50c4cfec5821b952f5545db5a_20191112032945_a107731c6c6a5e855fd837d7f79486c7_3](E:\mysql45讲\03eec4e50c4cfec5821b952f5545db5a_20191112032945_a107731c6c6a5e855fd837d7f79486c7_3.jpeg)

update T set c= c+1 where id =2

1.redo log 物理日志， 

​	存储了数据被修改的值

​	保证crash-safe 能力，当数据库异常重启后，通过redo log刷新到磁盘

​	 redo log本身也由两部分所构成即重做日志缓冲(redo log buffer)和重做日志文件(redo log file)。 

2.bin log  逻辑日志，

​	存储逻辑sql修改语句

​	主要用于备份数据

3.两段提交  1.relog prepare  2. 写入binlog 3.relog commit 保证redo log 和bin log的数据一致性



### 事物隔离

1.ACID

​	atomic原子性  consistency 一致性  isolation  隔离性   durabilityd 持久性

2.多个事务同时执行的时候 可能会出现 

​	数据丢失			    A 事务修改的数据 B事物回滚 导致 A事物修改的丢失

​	脏读   				     A事务读取 到 B事物中没有提交的数据

​	不可重复读             A事务本流程 读取到的数据 前后不一致 因为 B事物对读取数据的修改

​	幻读

#### 对应的隔离级别

​	读未提交 	一个事务读取到 另一个事务未提交的数据——

​	读提交		一个事务读取到 另一个事务已提交的数据—— [RC]

​	可重复度	一个事务读取到的数据 在 另一个事务未提交的数据（A）  和 已提交数据（A+1） 是一致的—— 如果这个事务读取到的是A ，那么不管另一个事务是否修改A，在这个事务本次过程中一直为A	[RR]

​	串行化  	 一个事务执行 修改逻辑后会被锁住， 先开的事务的提交后，这个事务才会继续执行



mysql的默认隔离级别是 RR 可重复读

Spring事物使用 RC 读已提交 

#### 事务隔离的实现

​	在Mysql中，每条记录在更新的时候都会同时记录一条回滚操作，记录上的最新值，通过回滚操作，可以得到前一个状态的值。同一条记录在系统中可与存在多个版本，这就是数据库的多版本并发控制

#### 避免使用长事务

长事务意味着系统里面有很老的事务视图，大量的会晕记录，占用存储空间

 INNODB_TRX   当前innodb内部正在运行的事务信息，包括只读事务 

#### 事物的启动

autocommit =0 关闭事务自动提交

autocommit =1 开启事务自动提交

### 索引

### Mysql大表调优三部曲

```java
1.慢查询
    SET GLOBAL slow_query_log = 1
2.Explain
    select 具体的索引
    type
    	system
    	const
    	eq_ref
    	ref
    	range
    	index
    	all
    key
    rows
    ref
    
3.Profile    
    查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等
     show profiles query_id
    打开表 初始化 执行表 sendingdata
    从连接 - 服务 - 引擎 - 存储四层结构完整生命周期的耗时
4.大表超过5000W条
    1.进行分表 
    	垂直分表： 主键+常用列 放在原表中，再讲 主键+一些不常用列 放在另外的表中		
    	水平分表
    		按照时间分表 日志数据等
    		按照区间分表 id自增 1~1000一张表table1 1001~2000一张表table2，2001~3000一张表table3，并且新建一张表 维护 表名+起始值
    		
    		hash分表 id通过 hash算法 
    	水平分表后，对于增删改查 先确定 对应的表
    	水平分表后 对于自增主键ID的解决方案
    		1.新建一张表维护id 新增的时候 先insert一条语句，每次从这张表拿出下一个id
    		2.使用队列服务，如redis、memcacheq等等，将一定量的ID预分配在一个队列里，每次插入操作，先从队列中获取一个ID，若插入失败的话，将该ID再次添加到队列中，同时监控队列数量，当小于阀值时，自动向队列中添加元素
    		3.redis生成
    			成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回
    2.读写分离 主从复制
    
```

### 分表后的全局唯一Id

```java
1.UUID
    无序、无法保证趋势递增（要求3）字符存储、传输、查询慢、不可读
2.雪花算法：
    雪花算法是一个64字节的long类型数字，其中各部分含义如下。
	1，第一部分1个 bit：0，这个是无意义的，它保证了我们的二进制中的首位为0，如果为1则为负数。
	2，第二部分41个 bit：表示的是单位为毫秒的时间戳，来保证我们的id是有序的。
	3，第三部分是10个 bit：前5个bit表示的是机房id，最多可以有32个机房；后5个bit表示的是机器id，最多可以有32台机器；
	4，最后部分是12个 bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的 id 的序号，可以保证一毫秒内有4096个id；
    
```

