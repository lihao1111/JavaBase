### JVM知识点

#### java特性

封装

​	将不需要的代码隐藏起来，对外提供的属性，提供公共方法进行访问

​	提高安全性 提高重用性

继承

​	extends 继承父类 重写父类方法

多态 

​    一种方法可以有多个版本的实现方式

​	方法的重载和方法的重写

#### 对象的创建

1.1遇到 new 会查看方法区是否有该类的信息，若果没有会加载类模板信息。

1.2分配内存，其中有两种方式:指针碰撞（java堆中内存是绝对规整的）和空闲列表(针对不规整的内存，jvm维护一个列表，记录那些内存块是可用的)。

1.3初始零值，针对类中的属性进行初始化零值，我们创建对象的属性中都有默认零值。

1.4对象头赋值，其中包括GC age hashCode 锁状态信息

1.5执行init函数，进行实例化

#### 对象的组成

1.对象头 header	

​	1.1运行时的数据：对象 GC age、hashCode、线程持有的锁状态等

​	1.2类型指针。对象指向的 类的元数据指针

2.实例数据 instance data

​	程序代码中所定义的各种类型的字段内容	

3.填充数据 padding

​	占位

#### 对象的访问

1.句柄访问	GC效率高 便于GC频率高的对象

​	java 栈中存放的是 句柄地址 句柄指针 到 句柄池  到 对象实例

2.直接指针访问 速度快，便于访问频繁的对象

​	java 栈中存放的是 对象地址  对象地址 到 对象的实例数据

### jvm是什么

1.JVM是运行编译好字节码(.class)的虚拟机

2.JVM = 类加载器 classloader + 运行时数据区 + 执行引擎

类加载器加载编译好的.class文件，将所有类结构和方法变量放入到运行时数据区，初始化后，将程序执行权交给执行引擎，JIT编译器，负责将字节码编译为平台特定的二进制码，调用本地接口库，完成程序执行。

其中垃圾回收器作为执行引擎一部分，负责维护运行时数据区中可变的内存空间。



类编译加载的流程图

![img](https://static001.geekbang.org/resource/image/8d/17/8d4ec9c73ec37d69adb105aa7d052717.jpg) 



#### 类加载器

BootStrapClassLoader -> ExtClassLoader -> ClassLoader   自上至下加载  双亲委派和沙箱安全机制。

#### JVM运行时数据区的结构

从线程分为：线程共享  堆 方法区；线程私有：程序计数器	本地方法栈	方法栈。

堆：实例对象，数组

方法区：静态变量   类信息	常量池

##### 堆的划分

新生区(1)  +养老区(2)[Full GC]

其中新生区包括：伊甸园区(8)[轻GC频率较高]+幸存From(1)+幸存To(1)          



 ![img](https://static001.geekbang.org/resource/image/99/6c/9906824978c891c86524f9394102de6c.png)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

### 执行引擎

执行引擎 = JIT （编译器） + GarbageCollecter（垃圾回收器）

#### 什么时候对象是没有用的

1.引用计数

2.可达性 GCROOT对象到该对象形成的链路

细致：1.强引用	2.软引用	3.弱引用	4.虚引用

#### Minor GC Major GC FullGC

```java
1.MinorGC：从年轻代回收内存
2.MajorGC:从年老代回收内存
3.FullGC：整个堆对象回收内存
```

### 什么时候会发生FullGC

1.养老代空间不足

2.元空间不足

3.CMS GC发生promotion failed 和 concurrent mode failure

```java
1.promotion failed 
    Minor GC时，Survior Space放不下，对象只能放入老年代，而此时老年代也放不下造成
2.concurrent node failure
    在执行 cms GC时，业务线程将对象放入老年代，而此时老年代空间不足，这时CMS还没有机会回收老年代产生的。
尽管CMS使用一个叫做分配担保的机制，每次Minor GC之后要保证新生代的空间survivor + eden > 老年带的空闲时间，但是对象分配是不可预测的，总会有写对象分配在老年带是满足不了的
解决方案：
    在CMS GC之前进行一个 标记整理算法，将内存碎片规划为 规整内存。
```

4.System.gc()

5.堆内存中直接分配大对象，没有连续空间分配 （标记-清理）

#### GC的算法

1.复制算法：不会产生内存锁片，内存利用率较低，多适用于伊甸园

2.标记-清理：将可用对象标记，将垃圾对象清理，会产生内存锁片，出现不连续的内存空间

3.标记-清理-压缩 【标记-整理】：将可用对象标记，将垃圾对象清理，然后在进行一个压缩。比较耗时，会进行三次内存扫描

4.分代使用 不同年代的区域根据特性使用不同的算法 【新生代 每次垃圾回收都有大量对象死去，只有少量存活，选用复制算法比较合理；老年代 对象存活率比较高，没有额外的空间分配对它进行担保，所以必须使用 标记-清理 这种相关算法】

### 垃圾回收器

```html
GC算法是内存回收的理论，垃圾回收器是内存回收的具体实践
```

 ### 新生代垃圾收集器

#### Serial收集器  （复制算法） 

单线程收集器，只有一个CPU或者一个收集线程进行垃圾回收任务，并且在进行垃圾回收时，必须暂停其它所有的工作线程，直到收集结束。	 Stop The World 

#### PerNew 收集器  （复制算法） 

ParNew多条垃圾收集线程并行工作，用户处于等待状态

### Parallel Scavenge 收集器  （复制算法） 

### 老生代垃圾收集（标记-整理）

#### Serial Old 

是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法

### Parallel Old （标记-整理”）

收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法

### CMS（Concurrent Mark Sweep）

收集器是一种以获取最短回收停顿时间为目标的收集器，优点是：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）

CMS收集器是使用**“标记-清除”**算法进行的垃圾回收，容易产生内存碎片

### G1

G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

```java
垃圾回收器从线程运行情况分类有三种
	串行回收，Serial回收器，单线程回收，全程stw；
	并行回收，名称以Parallel开头的回收器，多线程回收，全程stw；
	并发回收，cms与G1，多线程分阶段回收，只有某阶段会stw；
```



#### JVM调优

命令 top pidstat jstack jmap

1.为什么要进行调优？

​	保证服务的稳定性，找到合适该服务运行的参数。

2.jvm调优主要针对 堆内存的GC

​	Full GC 执行时间过长，Full GC执行频率过高

3.造成 频繁Full GC 以及Full GC时间过长的原因

​	过大对象以及数组直接在年老代生成

​	静态变量过多

​	新生代 GC没有过滤掉应该过滤的对象，大量对象直接进入年老代

4.调优的步骤

jmap  jstat命令

​	1.生成dump文件 jmap -dump format=b,file = heapdump.phrof pid

​	2.MAT打开 dump文件

​	3.分析指标

​			Minor GC的执行时间 以及执行频率

​				执行时间 不超过50ms

​				执行频率 大约   10s 一次

​			Full GC 的执行时间以及执行频率

​				执行时间	小于1s

​				执行频率	不低于10分钟一次

​	4.调整参数 进行压力测试	

​	5.基本参数

​			-Xms 堆内存大小

​			-Xmx 最大堆内存大小

​			-XX:NewSize 年轻代大小

​			-XX:MaxNewSize 年轻代最大值

​			-XX:PermSize 年老代大小

​			-XX:MaxPermSize 年老代最大值  

​			年轻代和年老代 默认 1:2

​			年轻代  -XX:newSize		-XX:MaxNewSize

​			如果存在大量临时对象 ，增大年轻代；如果存在过多持久对象，增大年老代

​			在多核 大内存 为年老代配置 并行收集算法 -XX:UseParallelOldGC

### 注意

jvm hotspot jdk1.8只有 将方法区 实现 改为  **元空间 meta space**    **取代永久代**

 过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： 

 -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 

### 记录生产环境CPU 100%排查流程

```java
1.top 查出来占用cpu最高的 进程
2.top -Hp pid  查询进程中占用最高的线程（-H 指显示线程，-p 是指定进程 ） 将其线程 转为 16进制    
3.jstack pid >> aa.log 将堆栈信息输出到文件中，查看具体哪一行代码有问题   或者使用 jstack pid |grep 找到线程转为16进制
    
```

### 记录生成环境内存暴增的排查流程

```java
1.top 			  查看占用内存 MEN 最高的进程。 
2.top -Hp pid     查看具体线程占用系统资源情况。 
3.jstack pid	  查看具体线程的堆栈信息
4.jmap    		  查看堆内存的使用情况
    jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图
5.jmap -dump format=b,file = heapdump.phrof pid  
    dump 的内存日志 MAT界面分析
```



### question

#### 当创建一个100M的大对象的时候，发现OOM，但是dump日志分析，堆内存大于100M？

有可能是 垃圾回收机制，使用到的标记-清理，造成内存碎片，没有一个100M的空闲内存分配，所以会造成OOM。

####  JVM 堆内存溢出后，其他线程是否可继续工作？ 

一般情况下 发生OOM的线程都会终结，该线程持有的对象占用的heap都会被gc了，释放内存。因为发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。

也就是说发生OOM的线程一般情况下会死亡，也就是会被终结掉，该线程持有的对象占用的heap都会被gc了，释放内存。因为发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。



### 程序执行

![image-20200222100616868](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200222100616868.png)



每个jvm进程都有自己的虚拟内存， jvm内存属于物理内存 默认占 1/4物理内存大小





![image-20200222100709333](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20200222100709333.png)

